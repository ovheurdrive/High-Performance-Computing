\documentclass[11pt, a4paper]{article}

\usepackage[frenchb]{babel}
\usepackage{fancyhdr} % Required for custom headers
\usepackage{lastpage} % Required to determine the last page for the footer
\usepackage{extramarks} % Required for headers and footers
\usepackage[usenames,dvipsnames]{color} % Required for custom colors
\usepackage{graphicx} % Required to insert images
\usepackage{listings} % Required for insertion of code
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{stmaryrd}
\usepackage{algpseudocode}
\usepackage[frenchb]{babel}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{times}
% Margins
\topmargin=-0.45in
\evensidemargin=0in
\oddsidemargin=0in
\textwidth=6.5in
\textheight=9.0in
\headsep=0.25in

\linespread{1.1} % Line spacing

% Set up the header and footer
\pagestyle{fancy}
\lhead{\hmwkAuthorName} % Top left header
\chead{\hmwkTitle} % Top center head
\rhead{\firstxmark} % Top right header
\lfoot{\lastxmark} % Bottom left footer
\cfoot{} % Bottom center footer
\rfoot{Page\ \thepage\ sur\ \protect\pageref{LastPage}} % Bottom right footer
\renewcommand\headrulewidth{0.4pt} % Size of the header rule
\renewcommand\footrulewidth{0.4pt} % Size of the footer rule

\setlength\parindent{0pt} % Removes all indentation from paragraphs

%----------------------------------------------------------------------------------------
%       CODE INCLUSION CONFIGURATION
%----------------------------------------------------------------------------------------

\lstloadlanguages{C} % Load Perl syntax for listings, for a list of other languages supported see: ftp://ftp.tex.ac.uk/tex-archive/macros/latex/contrib/listings/listings.pdf
\lstset{texcl=true, columns=flexible,basicstyle=\small\ttfamily}

\lstdefinestyle{ccode}{language=C, % Use Perl in this example
        frame=single, % Single frame around code
        basicstyle=\small\ttfamily, % Use small true type font
        keywordstyle=[1]\color{Blue}, % Perl functions bold and blue
        keywordstyle=[2]\color{Green}, % Perl function arguments purple
        keywordstyle=[3]\color{Blue}, % Custom functions underlined and blue
        identifierstyle=, % Nothing special about identifiers
        commentstyle=\small\color{Brown}, % Comments small dark green courier font
        stringstyle=\color{OliveGreen}, % Strings are purple
        showstringspaces=false, % Don't put marks in string spaces
        tabsize=5, % 2 spaces per tab
        %
        % Put standard Perl functions not included in the default language here
        morekeywords={f, sequantial_computation, parallel_computation, printf},
        morecomment=[l][\color{Blue}]{...}, % Line continuation (...) like blue comment
        numbers=left, % Line numbers on left
        firstnumber=1, % Line numbers start with line 1
        numberstyle=\tiny\color{Blue}, % Line numbers are blue and small
        stepnumber=5, % Line numbers go in steps of 5
        texcl=true,
        columns=flexible
}

% Creates a new command to include a perl script, the first parameter is the filename of the script (without .pl), the second parameter is the caption
\newcommand{\cscript}[2]{
\begin{itemize}
\item[]\lstinputlisting[caption=#2,label=#1]{#1.pl}
\end{itemize}
}


\newcommand{\problemAnswer}[1]{ % Defines the problem answer command with the content as the only argument
\noindent\framebox[\columnwidth][c]{\begin{minipage}{0.98\columnwidth}#1\end{minipage}} % Makes the box around the problem answer and puts the content inside
}

%----------------------------------------------------------------------------------------
% NAME AND CLASS SECTION
%----------------------------------------------------------------------------------------

\newcommand{\hmwkTitle}{Project : Jacobi Method in Parallel for Equation resolution} % Assignment title
\newcommand{\hmwkClass}{High Performance Computing} % Course/class
\newcommand{\hmwkClassInstructor}{F. Magoules} % Teacher/lecturer
\newcommand{\hmwkAuthorName}{Plessia Stanislas} % Your name

%----------------------------------------------------------------------------------------
% TITLE PAGE
%----------------------------------------------------------------------------------------

\title{
\LARGE{\textbf{\hmwkClass}}\\
\vspace{0.5in}
\large{\textbf{\hmwkTitle}}
\vspace{3in}
}

\author{\textbf{\hmwkAuthorName}}
\date{Mars 2018} % Insert date here if you want it to appear below your name

%----------------------------------------------------------------------------------------

\begin{document}

\maketitle

%----------------------------------------------------------------------------------------
% TABLE OF CONTENTS
%----------------------------------------------------------------------------------------

%\setcounter{tocdepth}{1} % Uncomment this line if you don't want subsections listed in the ToC

\newpage
\tableofcontents
\newpage

\section{Introduction}

\section{Methode de Jacobi}

\subsection{Problème}

Soit $n \in \mathbb{N}$ , $A = (a_{i,j})_{i,j \in \llbracket 1,n \rrbracket^2}$ matrice carrée de taille $n$, $b = (b_i)_{i \in \llbracket 1,n \rrbracket}$ vecteur de taille $n$.

On cherche alors le vecteur $x = (x_i)_{i \in \llbracket 1,n \rrbracket}$ tel que :

\begin{equation} 
    \label{eq:probleme}
    Ax = b
\end{equation}

\subsection{Méthode de résolution}

Afin de résoudre ce problème, on va utiliser une méthode itérative appellée Méthode de Jacobi.\\

Tout d'abord, on va séparer la matrice $A$ en deux sous matrices $D$ et $R$ de la manière suivante :\\

\[
A = 
\begin{pmatrix}
    a_{1,1} & a_{1,2} & \cdots & a_{1,n} \\
    a_{2,1} & a_{2,2} & \cdots & a_{2,n} \\
    \vdots & \vdots & \ddots & \vdots \\
    a_{n,1} & a_{n,2} & \cdots & a_{n,n} 
\end{pmatrix}
=
\begin{pmatrix}
    a_{1,1} & 0 & \cdots & 0 \\
    0 & a_{2,2} & \cdots & 0 \\
    \vdots  & \vdots  & \ddots & \vdots  \\
    0 & 0 & \cdots & a_{n,n}
\end{pmatrix}
+
\begin{pmatrix}
    0 & a_{1,2} & \cdots & a_{1,n} \\
    a_{2,1} & 0 & \cdots & a_{2,n} \\
    \vdots  & \vdots  & \ddots & \vdots  \\
    a_{n,1} & a_{n,2} & \cdots & 0
\end{pmatrix}
\]\\

Notons $D$ la matrice diagonale, et $R$ la matrice du reste.
Comme la matrice $D$ est diagonale (qu'on suppose à coefficients nons nuls dans notre problème), $D$ est trivialement inversible d'inverse : \\

\[
D^{-1} =
  \begin{pmatrix}
  \frac{1}{a_{1,1}} & 0 & \cdots & 0 \\
  0 & \frac{1}{a_{2,2}} & \cdots & 0 \\
  \vdots  & \vdots  & \ddots & \vdots  \\
  0 & 0 & \cdots & \frac{1}{a_{n,n}}
 \end{pmatrix}
\]

On peut donc réécrire la formule \eqref{eq:probleme} de la manière qui suit :

\begin{align}
& (D + R)x = b\\
\Leftrightarrow \qquad & Dx = b - Rx \\
\Leftrightarrow \qquad & x = D^{-1}(b - Rx)
\end{align}

La Méthode de Jacobi est alors unt méthode itérative qui va chercher à trouver un point fixe à cet équation. On peut alors définir la suite $x^{(k)}, k \in \mathbb{N}$ telle que :

\[
    \left\{
    \begin{array}{l}
        x^{(0)} = \vec{0}\\
        x^{(k+1)} = D^{-1}( b - Rx^{(k)})
    \end{array}
    \right.
\]

L'avantage flagrant de cette méthode de calcul, est que les éléments n'ont aucune dépendance verticale. Elle est donc très simple à parallèliser. 

En effet,en écrivant la formule de recurance pour un élement du vecteur $x^{(k+1)}$, on obtient :

\begin{align}
    \forall k \in \mathbb{N}, \forall i \in \llbracket 1,n \rrbracket, 
    \qquad x_{i}^{k+1} = \dfrac{1}{a_{i,i}}(b_i - \sum_{i \neq j}a_{i,j} \times x^{(k)}_j)
\end{align}

La seul contrainte devient alors que chaque processeur doit conna\^itre toutes les composantes de $x^{(k)}$ afin de pouvoir itérer, et il faut donc les communiquer, ce que nous feront en utilisant la bibliothèque MPI.

\subsection{Preuve et Convergence}

D'après le théorème de la méthode du point fixe, on sait que la suite $x_{n+1} = f(x_n)$ converge si la fonction $f$ est contractante aka $k$-lipshitzienne avec $k < 1$

La matrice $D^{-1}R$ étant une application linéaire, trouvons une condition nécessaire et suffisante pour qu'elle soit contractante \\

Soit $a,b$ deux vecteurs dans $\mathbb{R}^n$, $k \in [0,1[$ et notons $C = D^{-1}R$ , 

\begin{align}
    &|Ca - Cb| \leq k|a-b|\\
    \Leftrightarrow \qquad & ||C - kI|| \leq 0
\end{align}

Cela revient à dire que le rayon spectral de la matrice $C$ noté $\rho(C)$ doit \^etre strictement inférieur à 1

On peut donc affirmer que :

\[
\lim_{k \to \infty}x^{(k)} = x \Leftrightarrow \rho(C) = \rho(D^{-1}R) < 1
\]

\newpage 

Cherchons une condition simple suffisante pour affirmer que le rayon spectral de la matrice $C$ soit inférieur à 1.\\

Soit $\lambda$ valeur propre de $C$ ie $\forall y \in \mathbb{R}^n, Cy = \lambda y$

On a alors, $\forall (i,j) \in \llbracket 1,n \rrbracket^2$

\begin{align}
    &||\lambda y||_{\infty} = |\sum_{j=1}^{n}c_{i,j}y_j\\
    \Leftrightarrow \qquad & \lambda||y||_{\infty} = |\sum_{j \neq i}\dfrac{a_{i,j}}{a_{i,i}}y_j|\\
    \Leftrightarrow \qquad & \lambda||y||_{\infty} = |\dfrac{1}{a_{i,i}}| \times |\sum_{j \neq i}a_{i,j}y_j|\\
    \Leftrightarrow \qquad & \lambda||y||_{\infty} \leq |\dfrac{1}{a_{i,i}}| \times \sum_{j \neq i}|a_{i,j}y_j|\\
    \Leftrightarrow \qquad & \lambda||y||_{\infty} \leq |\dfrac{1}{a_{i,i}}| \times \sum_{j \neq i}|a_{i,j}| \times ||y||_{\infty}\\
    \Leftrightarrow \qquad & \lambda \leq |\dfrac{1}{a_{i,i}}| \times \sum_{j \neq i}|a_{i,j}|
\end{align}

Une condition suffisante pour que $\lambda < 1$ serait alors :

\[
\forall (i,j) \in \llbracket 1,n \rrbracket^2 \quad |a_{i,i}| > \sum_{i \neq j}|a_{i,j}|
\]
ie $A$ est à diagonale strictement dominante

\subsection{Vecteur erreur et résidu}

Afin de mesurer la convergence de la méthode de Jacobi (etd'avoir une condition d'arr\^et), on défini le vecteur erreur suivant :

\[
e^{(k+1)} = x^{(k+2)} - x^{(k+1)} = C(x^{(k+1)} - x^{(k)}) = Ce^{(k)}
\]

On a donc $e^{(k)} = C^ke^{(0)}$

$e$ est l'erreur relative de la méthode, mais comme on a pas connaissance du véritable vecteur $x$, on l'utilise comme référence pour le test d'arr\^et.

Le test d'arr\^et le plus courant de la méthode Jacobi est sur l'erreur relative du vecteur résidu :

\[
\epsilon > \dfrac{||r^{(k)}||}{||b||} = \dfrac{||De^{(k)}||}{||b||}
\]

\newpage

\section{Implémentation}

\subsection{Architecture}

Le projet est divisé en plusieurs sous-dossiers
\begin{itemize}
    \item \textbf{/lib} qui contient des librairies pour manipuler les matrices, les vecteurs ainsi que les opérations basiques de manipulation de ces deux structures de données.
    \item \textbf{/src} qui contient le fichier \textit{main} qui fait tourner le programme de l'agorithme de Jacobi.
    \item \textbf{/data} qui contient les fichiers des matrices et des vecteurs ainsi que les métadonnées contenant la taille des matrices considérées.
    \item \textbf{/bin} qui contientles binaires \textit{main} et \textit{test} afin de faire tourner le programme ou de tester les librairies
    \item \textbf{/test} qui contient le code source du binaire de test dont l'objectif est de tester les fonctions des lirbairies.
\end{itemize}
Le projet est de plus constitué d'un Makefile qui contient les procédures suivantes :
\begin{itemize}
    \item \textit{make all} (ou simplement \textit{make}) pour compiler les librairies, main et les tests 
    \item \textit{make test} pour compiler les tests 
    \item \textit{make clean} pour supprimer les fichiers objets
\end{itemize}

\subsection{Structures de données}

Dans ce projet, j'ai créé deux structures de données realitvement similaires pour les vecteurs et les matrices. Chaque structure dispose d'un type complexe qui lui est associé pour des raisons d'ergonomie.\\

Ces structures sont contenues dans les fichiers \texttt{lib/matrix.h} et \texttt{lib/vector.h}.\\

La structure Matrice est composé de deux entiers non signés pour les dimensions et d'un tableau de \textit{double} à 2 dimensions pour contenir les valeurs de la matrice.\\

La structure Vecteur est très similaire mais n'a qu'une seule dimension.\\

\subsection{Librairies}

Ce projet est fourni avec 3 libraries situées dans les fichiers C du dossier \textbf{/lib}.

\end{document}